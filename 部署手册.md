

### WordPress微服务化和多租户支持部署手册

#### 1. 系统环境准备

1.1 安装Docker和Docker Compose

在所有服务器上安装Docker和Docker Compose。以下是安装命令：

```bash
# 安装Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh

# 安装Docker Compose
sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

# 验证安装
docker --version
docker-compose --version
```

1.2 安装Git

```bash
# 安装Git
sudo apt-get update
sudo apt-get install git -y

# 验证安装
git --version
```

1.3 安装Node.js和npm

```bash
# 安装Node.js和npm
curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -
sudo apt-get install -y nodejs

# 验证安装
node -v
npm -v
```

#### 2. 获取项目代码

将项目代码克隆到本地：

```bash
git clone https://github.com/your-repo/wordpress-microservices.git
cd wordpress-microservices
```

#### 3. 配置文件

3.1 配置`wp-config.php`

创建`src/wp-config.php`文件，并添加以下内容：

```php name=src/wp-config.php
<?php
// 获取当前请求的域名或路径，以确定租户ID
$host = $_SERVER['HTTP_HOST'];
$tenantId = getTenantIdByHost($host);

// 加载数据库配置
$dbConfig = include(__DIR__ . '/config/database.php');

// 定义当前租户的数据库连接
define('DB_HOST', $dbConfig['tenants'][$tenantId]['host']);
define('DB_NAME', $dbConfig['tenants'][$tenantId]['name']);
define('DB_USER', $dbConfig['tenants'][$tenantId]['user']);
define('DB_PASSWORD', $dbConfig['tenants'][$tenantId]['password']);

// Multisite配置
define('WP_ALLOW_MULTISITE', true);
define('MULTISITE', true);
define('SUBDOMAIN_INSTALL', false);
define('DOMAIN_CURRENT_SITE', 'example.com');
define('PATH_CURRENT_SITE', '/');
define('SITE_ID_CURRENT_SITE', 1);
define('BLOG_ID_CURRENT_SITE', 1);

// 动态获取租户ID的函数
function getTenantIdByHost($host) {
    // 实现域名到租户ID的映射逻辑
    // 例如，可以查询数据库或配置文件进行映射
    // 这里假设存在一个简单的映射数组
    $tenantMapping = [
        'tenant1.example.com' => 'tenant1',
        'tenant2.example.com' => 'tenant2',
        // 添加其他租户映射
    ];

    return isset($tenantMapping[$host]) ? $tenantMapping[$host] : null;
}

// 定义插件和主题的自定义路径
define('WP_CONTENT_DIR', __DIR__ . '/wp-content');
define('WP_PLUGIN_DIR', WP_CONTENT_DIR . '/' . $tenantId . '/plugins');
define('WP_PLUGIN_URL', 'http://' . $_SERVER['HTTP_HOST'] . '/wp-content/' . $tenantId . '/plugins');
define('WP_THEME_DIR', WP_CONTENT_DIR . '/' . $tenantId . '/themes');
define('WP_THEME_URL', 'http://' . $_SERVER['HTTP_HOST'] . '/wp-content/' . $tenantId . '/themes');

// 其他WordPress配置
```

3.2 配置`nginx.conf`

创建`nginx.conf`文件，并添加以下内容：

```plaintext name=nginx.conf
user  nginx;
worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    keepalive_timeout  65;

    server {
        listen       80;
        server_name  example.com;

        root /var/www/html;
        index index.php index.html index.htm;

        location / {
            try_files $uri $uri/ /index.php?$args;
        }

        location ~ \.php$ {
            include fastcgi_params;
            fastcgi_pass unix:/var/run/php/php8.0-fpm.sock;
            fastcgi_index index.php;
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        }

        location ~ /\.ht {
            deny all;
        }
    }
}
```

3.3 配置`docker-compose.yml`

创建`docker-compose.yml`文件，并添加以下内容：

```yaml name=docker-compose.yml
version: '3.8'

services:
  wordpress:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "80:80"
    volumes:
      - ./src:/var/www/html
      - ./nginx.conf:/etc/nginx/nginx.conf
    environment:
      WORDPRESS_DB_HOST: db
      WORDPRESS_DB_USER: root
      WORDPRESS_DB_PASSWORD: root
      WORDPRESS_DB_NAME: wordpress

  db:
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: wordpress
    volumes:
      - db_data:/var/lib/mysql

volumes:
  db_data:
```

#### 4. 构建和启动容器

在项目根目录下执行以下命令：

```bash
# 构建Docker镜像
docker-compose build

# 启动Docker容器
docker-compose up -d
```

#### 5. 初始化数据库

5.1 进入数据库容器：

```bash
docker-compose exec db bash
```

5.2 连接到MySQL数据库：

```bash
mysql -u root -p
# 输入密码：root
```

5.3 创建数据库和用户：

```sql
CREATE DATABASE wordpress;
CREATE USER 'wp_user'@'%' IDENTIFIED BY 'wp_password';
GRANT ALL PRIVILEGES ON wordpress.* TO 'wp_user'@'%';
FLUSH PRIVILEGES;
EXIT;
```

#### 6. 配置并安装WordPress Multisite

6.1 访问WordPress安装页面：

在浏览器中访问`http://example.com`并按照提示完成安装过程。

6.2 启用Multisite功能：

编辑`src/wp-config.php`文件，添加以下代码：

```php
/* Multisite */
define('WP_ALLOW_MULTISITE', true);
```

6.3 安装Multisite网络：

- 登录到WordPress管理后台。
- 进入“工具” -> “网络设置”。
- 根据提示配置Multisite网络。

6.4 更新`src/wp-config.php`和Nginx配置文件：

根据网络设置页面的提示，更新`src/wp-config.php`文件：

```php
/* Multisite */
define('WP_ALLOW_MULTISITE', true);
define('MULTISITE', true);
define('SUBDOMAIN_INSTALL', false);
define('DOMAIN_CURRENT_SITE', 'example.com');
define('PATH_CURRENT_SITE', '/');
define('SITE_ID_CURRENT_SITE', 1);
define('BLOG_ID_CURRENT_SITE', 1);
```

更新Nginx配置文件：

```plaintext name=nginx.conf
user  nginx;
worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    keepalive_timeout  65;

    server {
        listen       80;
        server_name  example.com;

        root /var/www/html;
        index index.php index.html index.htm;

        location / {
            try_files $uri $uri/ /index.php?$args;
        }

        location ~ \.php$ {
            include fastcgi_params;
            fastcgi_pass unix:/var/run/php/php8.0-fpm.sock;
            fastcgi_index index.php;
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        }

        location ~ /\.ht {
            deny all;
        }
    }
}
```

#### 7. 启用站点和用户注册功能

- 进入“网络管理” -> “设置”。
- 配置站点和用户注册选项，允许用户注册并创建新站点。
  - 选择“用户可以注册并创建他们自己的站点”。


#### 8. 部署API网关和微服务

##### 8.1 部署API网关

创建`api-gateway.js`文件，并添加以下内容：

```javascript name=api-gateway.js
const express = require('express');
const axios = require('axios');

const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());

app.post('/register', async (req, res) => {
    try {
        const tenantData = req.body;
        // 调用租户服务创建新租户
        const tenantResponse = await axios.post('http://tenant-service/tenants', tenantData);
        const tenantId = tenantResponse.data.id;

        // 初始化租户数据库和文件系统
        await axios.post(`http://initialization-service/tenants/${tenantId}/initialize`);

        res.status(201).send({ success: true, tenantId });
    } catch (error) {
        res.status(error.response?.status || 500).send(error.response?.data || { message: 'Internal Server Error' });
    }
});

app.use('/users', (req, res) => {
    const tenantId = req.headers['x-tenant-id']; // 假设租户ID通过请求头传递
    axios({
        method: req.method,
        url: `http://user-service/tenants/${tenantId}/users${req.url}`,
        data: req.body,
    }).then(response => {
        res.send(response.data);
    }).catch(error => {
        res.status(error.response.status).send(error.response.data);
    });
});

app.use('/posts', (req, res) => {
    const tenantId = req.headers['x-tenant-id'];
    axios({
        method: req.method,
        url: `http://post-service/tenants/${tenantId}/posts${req.url}`,
        data: req.body,
    }).then(response => {
        res.send(response.data);
    }).catch(error => {
        res.status(error.response.status).send(error.response.data);
    });
});

app.listen(PORT, () => {
    console.log(`API Gateway running on port ${PORT}`);
});
```

运行API网关：

```bash
node api-gateway.js
```

##### 8.2 部署微服务

为每个微服务（例如用户服务、帖子服务等）创建Dockerfile和启动脚本，确保它们可以通过API网关进行访问。

###### 8.2.1 创建用户服务

1. **创建用户服务的项目目录**

在项目根目录下创建`user-service`目录：

```bash
mkdir user-service
cd user-service
```

2. **创建`Dockerfile`**

创建`Dockerfile`文件，并添加以下内容：

```Dockerfile name=user-service/Dockerfile
# 使用Node.js的官方基础镜像
FROM node:14

# 将源代码复制到容器中
COPY . /usr/src/app

# 设置工作目录
WORKDIR /usr/src/app

# 安装依赖
RUN npm install

# 暴露端口
EXPOSE 3001

# 启动用户服务
CMD ["node", "user-service.js"]
```

3. **创建用户服务启动脚本**

创建`user-service.js`文件，并添加以下内容：

```javascript name=user-service/user-service.js
const express = require('express');
const app = express();
const PORT = process.env.PORT || 3001;

app.use(express.json());

app.get('/tenants/:tenantId/users', (req, res) => {
    // 返回特定租户的用户列表
    const tenantId = req.params.tenantId;
    res.send(`Returning users for tenant ${tenantId}`);
});

app.listen(PORT, () => {
    console.log(`User service running on port ${PORT}`);
});
```

4. **构建和启动用户服务容器**

返回到项目根目录，并更新`docker-compose.yml`文件以包含用户服务：

```yaml name=docker-compose.yml
version: '3.8'

services:
  wordpress:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "80:80"
    volumes:
      - ./src:/var/www/html
      - ./nginx.conf:/etc/nginx/nginx.conf
    environment:
      WORDPRESS_DB_HOST: db
      WORDPRESS_DB_USER: root
      WORDPRESS_DB_PASSWORD: root
      WORDPRESS_DB_NAME: wordpress

  db:
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: wordpress
    volumes:
      - db_data:/var/lib/mysql

  user-service:
    build:
      context: ./user-service
    ports:
      - "3001:3001"
    environment:
      NODE_ENV: production

volumes:
  db_data:
```

执行以下命令构建并启动所有服务：

```bash
docker-compose build
docker-compose up -d
```

###### 8.2.2 创建帖子服务

1. **创建帖子服务的项目目录**

在项目根目录下创建`post-service`目录：

```bash
mkdir post-service
cd post-service
```

2. **创建`Dockerfile`**

创建`Dockerfile`文件，并添加以下内容：

```Dockerfile name=post-service/Dockerfile
# 使用Node.js的官方基础镜像
FROM node:14

# 将源代码复制到容器中
COPY . /usr/src/app

# 设置工作目录
WORKDIR /usr/src/app

# 安装依赖
RUN npm install

# 暴露端口
EXPOSE 3002

# 启动帖子服务
CMD ["node", "post-service.js"]
```

3. **创建帖子服务启动脚本**

创建`post-service.js`文件，并添加以下内容：

```javascript name=post-service/post-service.js
const express = require('express');
const app = express();
const PORT = process.env.PORT || 3002;

app.use(express.json());

app.get('/tenants/:tenantId/posts', (req, res) => {
    // 返回特定租户的帖子列表
    const tenantId = req.params.tenantId;
    res.send(`Returning posts for tenant ${tenantId}`);
});

app.listen(PORT, () => {
    console.log(`Post service running on port ${PORT}`);
});
```

4. **构建和启动帖子服务容器**

返回到项目根目录，并更新`docker-compose.yml`文件以包含帖子服务：

```yaml name=docker-compose.yml
version: '3.8'

services:
  wordpress:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "80:80"
    volumes:
      - ./src:/var/www/html
      - ./nginx.conf:/etc/nginx/nginx.conf
    environment:
      WORDPRESS_DB_HOST: db
      WORDPRESS_DB_USER: root
      WORDPRESS_DB_PASSWORD: root
      WORDPRESS_DB_NAME: wordpress

  db:
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: wordpress
    volumes:
      - db_data:/var/lib/mysql

  user-service:
    build:
      context: ./user-service
    ports:
      - "3001:3001"
    environment:
      NODE_ENV: production

  post-service:
    build:
      context: ./post-service
    ports:
      - "3002:3002"
    environment:
      NODE_ENV: production

volumes:
  db_data:
```

执行以下命令构建并启动所有服务：

```bash
docker-compose build
docker-compose up -d
```

#### 9. 监控和日志

##### 9.1 安装和配置Prometheus和Grafana

1. **创建Prometheus配置文件**

在项目根目录下创建`prometheus.yml`文件，并添加以下内容：

```yaml name=prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']
  - job_name: 'user-service'
    static_configs:
      - targets: ['user-service:3001']
  - job_name: 'post-service'
    static_configs:
      - targets: ['post-service:3002']
```

2. **更新`docker-compose.yml`文件以包含Prometheus和Grafana服务**

```yaml name=docker-compose.yml
version: '3.8'

services:
  wordpress:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "80:80"
    volumes:
      - ./src:/var/www/html
      - ./nginx.conf:/etc/nginx/nginx.conf
    environment:
      WORDPRESS_DB_HOST: db
      WORDPRESS_DB_USER: root
      WORDPRESS_DB_PASSWORD: root
      WORDPRESS_DB_NAME: wordpress

  db:
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: wordpress
    volumes:
      - db_data:/var/lib/mysql

  user-service:
    build:
      context: ./user-service
    ports:
      - "3001:3001"
    environment:
      NODE_ENV: production

  post-service:
    build:
      context: ./post-service
    ports:
      - "3002:3002"
    environment:
      NODE_ENV: production

  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin

volumes:
  db_data:
```

3. **启动Prometheus和Grafana服务**

执行以下命令构建并启动所有服务：

```bash
docker-compose build
docker-compose up -d
```

4. **配置Grafana**

在浏览器中访问`http://localhost:3000`，使用默认用户名`admin`和密码`admin`登录。添加Prometheus数据源并创建仪表板进行数据可视化。

##### 9.2 安装和配置ELK栈

1. **更新`docker-compose.yml`文件以包含Elasticsearch、Logstash和Kibana服务**

```yaml name=docker-compose.yml
version: '3.8'

services:
  wordpress:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "80:80"
    volumes:
      - ./src:/var/www/html
      - ./nginx.conf:/etc/nginx/nginx.conf
    environment:
      WORDPRESS_DB_HOST: db
      WORDPRESS_DB_USER: root
      WORDPRESS_DB_PASSWORD: root
      WORDPRESS_DB_NAME: wordpress

  db:
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: wordpress
    volumes:
      - db_data:/var/lib/mysql

  user-service:
    build:
      context: ./user-service
    ports:
      - "3001:3001"
    environment:
      NODE_ENV: production

  post-service:
    build:
      context: ./post-service
    ports:
      - "3002:3002"
    environment:
      NODE_ENV: production

  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.10.1
    environment:
      discovery.type: single-node
    ports:
      - "9200:9200"
      - "9300:9300"

  logstash:
    image: docker.elastic.co/logstash/logstash:7.10.1
    ports:
      - "5044:5044"
    volumes:
      - ./logstash.conf:/usr/share/logstash/pipeline/logstash.conf

  kibana:
    image: docker.elastic.co/kibana/kibana:7.10.1
    ports:
      - "5601:5601"
    environment:
      ELASTICSEARCH_URL: http://elasticsearch:9200

volumes:
  db_data:
```

2. **创建Logstash配置文件**

在项目根目录下创建`logstash.conf`文件，并添加以下内容：

```plaintext name=logstash.conf
input {
  beats {
    port => 5044
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "logstash-%{+YYYY.MM.dd}"
  }
  stdout { codec => rubydebug }
}
```

3. **启动ELK栈**

执行以下命令构建并启动所有服务：

```bash
docker-compose build
docker-compose up -d
```

4. **配置Kibana**

在浏览器中访问`http://localhost:5601`，配置Kibana以查看日志数据。

#### 10. 安全性配置

##### 10.1 配置API认证与授权

使用OAuth2.0或JWT进行API认证与授权。可以使用OAuth2.0服务器（如Keycloak）或JWT库（如jsonwebtoken）进行配置。

##### 10.2 配置数据加密和DDoS防护

1. **配置TLS加密**

更新Nginx配置文件以支持TLS加密：

```plaintext name=nginx.conf
user  nginx;
worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
    keepalive_timeout  65;

    server {
        listen       443 ssl;
        server_name  example.com;

        ssl_certificate     /etc/nginx/ssl/nginx.crt;
        ssl_certificate_key /etc/nginx/ssl/nginx.key;

        root /var/www/html;
        index index.php index.html index.htm;

        location / {
            try_files $uri $uri/ /index.php?$args;
        }

        location ~ \.php$ {
            include fastcgi_params;
            fastcgi_pass unix:/var/run/php/php8.0-fpm.sock;
            fastcgi_index index.php;
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        }

        location ~ /\.ht {
            deny all;
        }
    }
}
```

2. **配置DDoS防护**

使用云服务提供商的DDoS防护服务（如AWS Shield或Cloudflare）来抵御DDoS攻击。

#### 11. 自动化CI/CD集成

##### 11.1 配置Jenkinsfile

创建`Jenkinsfile`文件，并添加以下内容：

```groovy name=Jenkinsfile
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                // 安装依赖
                sh 'composer install'
            }
        }
        stage('Test') {
            steps {
                // 运行单元测试
                sh 'vendor/bin/phpunit'
            }
        }
        stage('Deploy') {
            steps {
                // 部署应用
                sh 'docker-compose up -d'
            }
        }
    }
}
```

通过Jenkins或GitLab CI实现持续集成和持续部署，确保每次代码提交后自动进行构建、测试和部署。

### 部署完成

至此，WordPress微服务化和多租户支持的部署已完成。可以通过浏览器访问`http://example.com`进行多租户站点的管理和操作。
